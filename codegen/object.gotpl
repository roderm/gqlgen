{{- range $object := .Objects }}

var {{ $object.Name|lcFirst}}Implementors = {{$object.Implementors}}

{{- if .Stream }}
func (e *executableSchema) _{{$object.Name}}(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(graphql.GetOperationContext(ctx), sel, {{$object.Name|lcFirst}}Implementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: {{$object.Name|quote}},
	})
	if len(fields) != 1 {
		graphql.GetOperationContext(ctx).Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	{{- range $field := $object.Fields }}
	case "{{$field.Name}}":
		return e._{{$object.Name}}_{{$field.Name}}(ctx, fields[0])
	{{- end }}
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}
{{- else }}
func (e *executableSchema) _{{$object.Name}}_resolve_field(ctx context.Context, field graphql.CollectedField{{ if not $object.Root }},obj {{$object.Reference | ref }}{{ end }}) (func(*graphql.FieldSet, int) bool, error) {
	{{- if $object.Root }}
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field: field,
		})
	{{end}}
	switch field.Name {
	{{- range $field := $object.Fields }}
	case "{{$field.Name}}":
		{{- if $field.IsConcurrent }}
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						oc := graphql.GetOperationContext(ctx)
						oc.Error(ctx, oc.Recover(ctx, r))
					}
				}()
				res = e._{{$object.Name}}_{{$field.Name}}(ctx, field{{if not $object.Root}}, obj{{end}})
				{{- if $field.TypeReference.GQL.NonNull }}
					if res == graphql.Null {
						{{- if $object.IsConcurrent }}
							atomic.AddUint32(&invalids, 1)
						{{- else }}
							invalids++
						{{- end }}
					}
				{{- end }}
				return res
			}

			{{if $object.Root}}
				rrm := func(ctx context.Context) graphql.Marshaler {
					return graphql.GetOperationContext(ctx).RootResolverMiddleware(ctx, innerFunc)
				}
			{{end}}
			return func(out *graphql.FieldSet, i int) bool {
				out.Concurrently(i, func() graphql.Marshaler {
					{{- if $object.Root -}}
						return rrm(innerCtx)
					{{- else -}}
						return innerFunc(ctx)
					{{end}}
				})
				return true
			}, nil
		{{- else }}
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return e._{{$object.Name}}_{{$field.Name}}(ctx, field{{if not $object.Root}}, obj{{end}})
			}
			return func(out *graphql.FieldSet, i int) bool {
			{{if $object.Root}}
				out.Values[i] = graphql.GetOperationContext(ctx).RootResolverMiddleware(innerCtx, innerFunc)
			{{else}}
				out.Values[i] = innerFunc(ctx)
			{{end}}

			{{- if $field.TypeReference.GQL.NonNull }}
				return out.Values[i] != graphql.Null
			{{- else }}
				return true
			{{- end }}
			}, nil
		{{- end }}
	{{- end }}
	default:
		{{- if $object.Root }}
		for _, x := range e.rootResolve {
			if r, ok := x[{{$object.Name|quote}}]; ok {
				return r(ctx, field)
			}
		}
		{{- else }}
		for _, x := range e.fieldResolve {
			if r, ok := x[{{$object.Name|quote}}]; ok {
				return r(ctx, field, obj)
			}
		}
		{{- end }}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _{{$object.Name}}(ctx context.Context, sel ast.SelectionSet{{ if not $object.Root }}, obj {{$object.Reference | ref }}{{ end }}) graphql.Marshaler {
	fields := graphql.CollectFields(graphql.GetOperationContext(ctx), sel, {{$object.Name|lcFirst}}Implementors)
    {{- if $object.Root }}
        ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
            Object: {{$object.Name|quote}},
        })
	{{- else }}
    {{end}}
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString({{$object.Name|quote}})
			continue;
		}
		resolve, err := e._{{$object.Name}}_resolve_field(ctx, field{{ if not $object.Root }}, obj{{ end }} )
		if err != nil {
			panic(err)
		}
		ok := resolve(out,i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 { return graphql.Null }
	return out
}
{{- end }}

{{- end }}
