{{ reserveImport "context"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "io"  }}
{{ reserveImport "strconv"  }}
{{ reserveImport "time"  }}
{{ reserveImport "sync"  }}
{{ reserveImport "sync/atomic" }}
{{ reserveImport "errors"  }}
{{ reserveImport "reflect" }}
{{ reserveImport "bytes"  }}

{{ reserveImport "github.com/vektah/gqlparser/v2" "gqlparser" }}
{{ reserveImport "github.com/vektah/gqlparser/v2/ast" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/introspection" }}

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	s := &executableSchema{
		resolvers: cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
		sources: sources,
		schema: gqlparser.MustLoadSchema(sources...),
		fieldResolve: []map[string]func(context.Context, graphql.CollectedField, interface{}) (func(*graphql.FieldSet, int) bool, error){},
		rootResolve:  []map[string]func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error){},
	}
	return s
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
{{- range $object := .Objects -}}
	{{ if $object.HasResolvers -}}
		{{ucFirst $object.Name}}() {{ucFirst $object.Name}}Resolver
	{{ end }}
{{- end }}
}

type DirectiveRoot struct {
{{ range $directive := .Directives }}
	{{- $directive.Declaration }}
{{ end }}
}

type ComplexityRoot struct {
{{ range $object := .Objects }}
	{{ if not $object.IsReserved -}}
		{{ ucFirst $object.Name }} struct {
		{{ range $_, $fields := $object.UniqueFields }}
			{{- $field := index $fields 0 -}}
			{{ if not $field.IsReserved -}}
				{{ $field.GoFieldName }} {{ $field.ComplexitySignature }}
			{{ end }}
		{{- end }}
		}
	{{- end }}
{{ end }}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot

	sources      []*ast.Source
	schema       *ast.Schema
	fieldResolve []map[string]func(context.Context, graphql.CollectedField, interface{}) (func(*graphql.FieldSet, int) bool, error)
	rootResolve  []map[string]func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error)
}

func (e *executableSchema) Schema() *ast.Schema {
	return e.schema
}

func (e *executableSchema) SchemaSources() []*ast.Source {
	return e.sources
}

func (e *executableSchema) Extend(ext graphql.ExecutableSchema) error {
	e.sources = append(e.sources, ext.SchemaSources()...)
	newSchema, err := gqlparser.LoadSchema(e.sources...)
	if err != nil {
		return err
	}
	e.fieldResolve = append(e.fieldResolve, ext.GetFieldResolvers()...)
	e.rootResolve = append(e.rootResolve, ext.GetRootResolvers()...)
	e.schema = newSchema
	return nil
}

func (e *executableSchema) GetRootResolvers() []map[string]func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error){
	return []map[string]func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error){map[string]func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error){
	{{- range $object := .Objects }}
	{{- if $object.Root }}
		{{$object.Name|quote}}: e._{{$object.Name}}_resolve_field,
	{{- end }}
	{{- end }}
	}}
}

func (e *executableSchema) GetFieldResolvers() []map[string]func(context.Context, graphql.CollectedField, interface{}) (func(*graphql.FieldSet, int) bool, error){
	return  []map[string]func(context.Context, graphql.CollectedField, interface{}) (func(*graphql.FieldSet, int) bool, error){map[string]func(context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error){
	{{- range $object := .Objects }}
	{{- if not $object.Root }}
		{{$object.Name|quote}}: func(context.Context, graphql.CollectedField, interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.({{$object.Reference | ref }})
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e._{{$object.Name}}_resolve_field(ctx, field, obj)
		},
	{{- end }}
	{{- end }}
	}}
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	// ec := executionContext{nil, e, context.TODO()}
	// _ = ec
	switch typeName + "." + field {
	{{ range $object := .Objects }}
		{{ if not $object.IsReserved }}
			{{ range $_, $fields := $object.UniqueFields }}
				{{- $len := len $fields }}
				{{- range $i, $field := $fields }}
					{{- $last := eq (add $i 1) $len }}
					{{- if not $field.IsReserved }}
						{{- if eq $i 0 }}case {{ end }}"{{$object.Name}}.{{$field.Name}}"{{ if not $last }},{{ else }}:
						if e.complexity.{{ucFirst $object.Name }}.{{$field.GoFieldName}} == nil {
						break
						}
						{{ if $field.Args }}
							args, err := ec.{{ $field.ArgsFunc }}(&ec,rawArgs)
							if err != nil {
							return 0, false
							}
						{{ end }}
						return e.complexity.{{ucFirst $object.Name}}.{{$field.GoFieldName}}(childComplexity{{if $field.Args}}, {{$field.ComplexityArgs}} {{ end }}), true
						{{ end }}
					{{- end }}
				{{- end }}
			{{ end }}
		{{ end }}
	{{ end }}
	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		{{- range $input := .Inputs -}}
			{{ if not $input.HasUnmarshal }}
				ec.unmarshalInput{{ $input.Name }},
			{{- end }}
		{{- end }}
	)
	first := true

	switch rc.Operation.Operation {
	{{- if .QueryRoot }} case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first { return nil }
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			{{ if .Directives.LocationDirectives "QUERY" -}}
				data := ec._queryMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error){
					return ec._{{.QueryRoot.Name}}(ctx, rc.Operation.SelectionSet), nil
				})
			{{- else -}}
				data := ec._{{.QueryRoot.Name}}(ctx, rc.Operation.SelectionSet)
			{{- end }}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data:       buf.Bytes(),
			}
		}
	{{ end }}

	{{- if .MutationRoot }} case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first { return nil }
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			{{ if .Directives.LocationDirectives "MUTATION" -}}
				data := ec._mutationMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error){
					return ec._{{.MutationRoot.Name}}(ctx, rc.Operation.SelectionSet), nil
				})
			{{- else -}}
				data := ec._{{.MutationRoot.Name}}(ctx, rc.Operation.SelectionSet)
			{{- end }}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data:       buf.Bytes(),
			}
		}
	{{ end }}

	{{- if .SubscriptionRoot }} case ast.Subscription:
		{{ if .Directives.LocationDirectives "SUBSCRIPTION" -}}
			next := ec._subscriptionMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error){
				return ec._{{.SubscriptionRoot.Name}}(ctx, rc.Operation.SelectionSet),nil
			})
		{{- else -}}
			next := ec._{{.SubscriptionRoot.Name}}(ctx, rc.Operation.SelectionSet)
		{{- end }}

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data:       buf.Bytes(),
			}
		}
	{{ end }}
	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (e *executableSchema) introspectSchema(ctx context.Context) (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.schema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.schema, ec.schema.Types[name]), nil
}

var sources = []*ast.Source{
{{- range $source := .Config.Sources }}
	{Name: {{$source.Name|quote}}, Input: {{$source.Input|rawQuote}}, BuiltIn: {{$source.BuiltIn}}},
{{- end }}
}
